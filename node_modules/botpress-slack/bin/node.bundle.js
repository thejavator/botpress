module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/Users/slvn/Desktop/botpress-slack";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _botpressVersionManager = __webpack_require__(2);
	
	var _botpressVersionManager2 = _interopRequireDefault(_botpressVersionManager);
	
	var _outgoing = __webpack_require__(3);
	
	var _outgoing2 = _interopRequireDefault(_outgoing);
	
	var _actions = __webpack_require__(4);
	
	var _actions2 = _interopRequireDefault(_actions);
	
	var _lodash = __webpack_require__(6);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _bluebird = __webpack_require__(5);
	
	var _bluebird2 = _interopRequireDefault(_bluebird);
	
	var _umm = __webpack_require__(7);
	
	var _umm2 = _interopRequireDefault(_umm);
	
	var _slack = __webpack_require__(9);
	
	var _slack2 = _interopRequireDefault(_slack);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _bluebird2.default(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _bluebird2.default.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	var slack = null;
	
	var outgoingMiddleware = function outgoingMiddleware(event, next) {
	  if (event.platform !== 'slack') {
	    return next();
	  }
	
	  if (!_outgoing2.default[event.type]) {
	    return next('Unsupported event type: ' + event.type);
	  }
	
	  _outgoing2.default[event.type](event, next, slack);
	};
	
	module.exports = {
	
	  config: {
	    apiToken: { type: 'string', default: '', env: 'SLACK_API_TOKEN' },
	    botToken: { type: 'string', default: '', env: 'SLACK_BOT_TOKEN' },
	    clientID: { type: 'string', default: '', env: 'SLACK_CLIENT_ID' },
	    clientSecret: { type: 'string', default: '', env: 'SLACK_CLIENT_SECRET' },
	    hostname: { type: 'string', default: '', env: 'SLACK_HOST' },
	    verificationToken: { type: 'string', default: '', env: 'SLACK_VERIFICATION_TOKEN' },
	    scope: { type: 'string', default: 'admin,bot,chat:write:bot,commands,identify,incoming-webhook,channels:read', env: 'SLACK_SCOPE' }
	  },
	
	  init: function init(bp) {
	
	    (0, _botpressVersionManager2.default)(bp, __dirname);
	
	    bp.middlewares.register({
	      name: 'slack.sendMessages',
	      type: 'outgoing',
	      order: 100,
	      handler: outgoingMiddleware,
	      module: 'botpress-slack',
	      description: 'Sends out messages that targets platform = slack.' + ' This middleware should be placed at the end as it swallows events once sent.'
	    });
	
	    bp.slack = {};
	    _lodash2.default.forIn(_actions2.default, function (action, name) {
	      bp.slack[name] = _actions2.default[name];
	      var sendName = name.replace(/^create/, 'send');
	      bp.slack[sendName] = _bluebird2.default.method(function () {
	        var msg = action.apply(this, arguments);
	        return bp.middlewares.sendOutgoing(msg);
	      });
	    });
	
	    // Set up endpoints as internal functions
	    bp.slack['getUserProfile'] = function (id) {
	      return slack.getUserProfile(id);
	    };
	
	    bp.slack['getUsers'] = function () {
	      return slack.getUsers();
	    };
	
	    bp.slack['getChannels'] = function () {
	      return slack.getChannels();
	    };
	
	    bp.slack['getTeam'] = function () {
	      return slack.getTeam();
	    };
	
	    bp.slack['getData'] = function () {
	      return slack.getData();
	    };
	
	    (0, _umm2.default)(bp); // Initializes Slack in the UMM
	  },
	
	
	  ready: function () {
	    var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee4(bp, configurator) {
	      var _this = this;
	
	      var config, router, getStatus, setConfigAndRestart;
	      return regeneratorRuntime.wrap(function _callee4$(_context4) {
	        while (1) {
	          switch (_context4.prev = _context4.next) {
	            case 0:
	              _context4.next = 2;
	              return configurator.loadAll();
	
	            case 2:
	              config = _context4.sent;
	
	
	              slack = new _slack2.default(bp, config);
	
	              router = bp.getRouter('botpress-slack', { 'auth': function auth(req) {
	                  return !/\/action-endpoint/i.test(req.originalUrl);
	                } });
	
	              getStatus = function getStatus() {
	                return {
	                  connected: slack.isConnected()
	                };
	              };
	
	              setConfigAndRestart = function () {
	                var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee(newConfigs) {
	                  return regeneratorRuntime.wrap(function _callee$(_context) {
	                    while (1) {
	                      switch (_context.prev = _context.next) {
	                        case 0:
	                          _context.next = 2;
	                          return configurator.saveAll(newConfigs);
	
	                        case 2:
	                          slack.setConfig(newConfigs);
	                          slack.connect(bp);
	
	                        case 4:
	                        case 'end':
	                          return _context.stop();
	                      }
	                    }
	                  }, _callee, _this);
	                }));
	
	                return function setConfigAndRestart(_x3) {
	                  return _ref2.apply(this, arguments);
	                };
	              }();
	
	              slack.connect(bp);
	
	              router.get('/config', function () {
	                var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(req, res) {
	                  return regeneratorRuntime.wrap(function _callee2$(_context2) {
	                    while (1) {
	                      switch (_context2.prev = _context2.next) {
	                        case 0:
	                          _context2.t0 = res;
	                          _context2.next = 3;
	                          return configurator.loadAll();
	
	                        case 3:
	                          _context2.t1 = _context2.sent;
	
	                          _context2.t0.json.call(_context2.t0, _context2.t1);
	
	                        case 5:
	                        case 'end':
	                          return _context2.stop();
	                      }
	                    }
	                  }, _callee2, _this);
	                }));
	
	                return function (_x4, _x5) {
	                  return _ref3.apply(this, arguments);
	                };
	              }());
	
	              router.post('/config', function () {
	                var _ref4 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3(req, res) {
	                  return regeneratorRuntime.wrap(function _callee3$(_context3) {
	                    while (1) {
	                      switch (_context3.prev = _context3.next) {
	                        case 0:
	                          setConfigAndRestart(req.body);
	                          _context3.t0 = res;
	                          _context3.next = 4;
	                          return configurator.loadAll();
	
	                        case 4:
	                          _context3.t1 = _context3.sent;
	
	                          _context3.t0.json.call(_context3.t0, _context3.t1);
	
	                        case 6:
	                        case 'end':
	                          return _context3.stop();
	                      }
	                    }
	                  }, _callee3, _this);
	                }));
	
	                return function (_x6, _x7) {
	                  return _ref4.apply(this, arguments);
	                };
	              }());
	
	              router.get('/status', function (req, res) {
	                res.json(getStatus());
	              });
	
	              router.get('/user', function (req, res) {
	                slack.getUserProfile(req.query.id).then(function (user) {
	                  res.json(user);
	                });
	              });
	
	              router.get('/users', function (req, res) {
	                res.json(slack.getUsers());
	              });
	
	              router.get('/channels', function (req, res) {
	                slack.getChannels().then(function (channels) {
	                  res.json(channels);
	                });
	              });
	
	              router.get('/team', function (req, res) {
	                res.json(slack.getTeam());
	              });
	
	              router.get('/data', function (req, res) {
	                res.json(slack.getData());
	              });
	
	            case 16:
	            case 'end':
	              return _context4.stop();
	          }
	        }
	      }, _callee4, this);
	    }));
	
	    function ready(_x, _x2) {
	      return _ref.apply(this, arguments);
	    }
	
	    return ready;
	  }()
	};

/***/ },
/* 2 */
/***/ function(module, exports) {

	module.exports = require("botpress-version-manager");

/***/ },
/* 3 */
/***/ function(module, exports) {

	'use strict';
	
	var handlePromise = function handlePromise(event, next, promise) {
	  return promise.then(function (res) {
	    next();
	    event._resolve && event._resolve();
	    return res;
	  }).catch(function (err) {
	    next(err);
	    event._reject && event._reject(err);
	    throw err;
	  });
	};
	
	var handleText = function handleText(event, next, slack) {
	  if (event.platform !== 'slack' || event.type !== 'text') {
	    return next();
	  }
	
	  var channelId = event.raw.channelId;
	  var text = event.text;
	  var options = event.raw.options;
	
	  return handlePromise(event, next, slack.sendText(channelId, text, options));
	};
	
	var handleUpdateText = function handleUpdateText(event, next, slack) {
	  if (event.platform !== 'slack' || event.type !== 'update_text') {
	    return next();
	  }
	
	  var channelId = event.raw.channelId;
	  var text = event.text;
	  var options = event.raw.options;
	  var ts = event.raw.ts;
	
	  return handlePromise(event, next, slack.sendUpdateText(ts, channelId, text, options));
	};
	
	var handleAttachments = function handleAttachments(event, next, slack) {
	  if (event.platform !== 'slack' || event.type !== 'attachments') {
	    return next();
	  }
	
	  var channelId = event.raw.channelId;
	  var attachments = event.raw.attachments;
	  var options = event.raw.options;
	
	  return handlePromise(event, next, slack.sendAttachments(channelId, attachments, options));
	};
	
	var handleUpdateAttachments = function handleUpdateAttachments(event, next, slack) {
	  if (event.platform !== 'slack' || event.type !== 'update_attachments') {
	    return next();
	  }
	
	  var channelId = event.raw.channelId;
	  var attachments = event.raw.attachments;
	  var options = event.raw.options;
	  var ts = event.raw.ts;
	
	  return handlePromise(event, next, slack.sendUpdateAttachments(ts, channelId, attachments, options));
	};
	
	var handleDeleteTextOrAttachments = function handleDeleteTextOrAttachments(event, next, slack) {
	  if (event.platform !== 'slack' || event.type !== 'delete_text_or_attachments') {
	    return next();
	  }
	
	  var channelId = event.raw.channelId;
	  var options = event.raw.options;
	  var ts = event.raw.ts;
	
	  return handlePromise(event, next, slack.sendDeleteTextOrAttachments(ts, channelId, options));
	};
	
	var handleReaction = function handleReaction(event, next, slack) {
	  if (event.platform !== 'slack' || event.type !== 'reaction') {
	    return next();
	  }
	
	  var name = event.raw.name;
	  var options = event.raw.options;
	
	  return handlePromise(event, next, slack.sendReaction(name, options));
	};
	
	var handleRemoveReaction = function handleRemoveReaction(event, next, slack) {
	  if (event.platform !== 'slack' || event.type !== 'remove_reaction') {
	    return next();
	  }
	
	  var name = event.raw.name;
	  var options = event.raw.options;
	
	  return handlePromise(event, next, slack.sendRemoveReaction(name, options));
	};
	
	module.exports = {
	  'text': handleText,
	  'attachments': handleAttachments,
	  'reaction': handleReaction,
	  'update_text': handleUpdateText,
	  'update_attachments': handleUpdateAttachments,
	  'delete_text_or_attachments': handleDeleteTextOrAttachments,
	  'remove_reaction': handleRemoveReaction
	};

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _bluebird = __webpack_require__(5);
	
	var _bluebird2 = _interopRequireDefault(_bluebird);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var create = function create(obj) {
	  var resolve = null;
	  var reject = null;
	  var promise = new _bluebird2.default(function (r, rj) {
	    resolve = r;
	    reject = rj;
	  });
	
	  var messageId = new Date().toISOString() + Math.random();
	
	  var newEvent = Object.assign({
	    _promise: promise,
	    _resolve: resolve,
	    _reject: reject,
	    __id: messageId
	  }, obj);
	
	  return newEvent;
	};
	
	var validateChannelId = function validateChannelId(channelId) {
	  if (!/\w+/.test(channelId)) {
	    throw new Error('Invalid channel id');
	  }
	};
	
	var validateText = function validateText(text) {
	  if (typeof text !== 'string') {
	    throw new Error('Text must be a string.');
	  }
	};
	
	var validateAttachments = function validateAttachments(attachments) {
	  if ((typeof attachments === 'undefined' ? 'undefined' : _typeof(attachments)) !== 'object') {
	    throw new Error('Expected attachments type to be an object');
	  }
	};
	
	var createText = function createText(channelId, text) {
	  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	
	  validateChannelId(channelId);
	  validateText(text);
	
	  return create({
	    platform: 'slack',
	    type: 'text',
	    text: text,
	    raw: {
	      channelId: channelId,
	      options: options
	    }
	  });
	};
	
	var createAttachments = function createAttachments(channelId, attachments) {
	  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	
	  validateChannelId(channelId);
	  validateAttachments(attachments);
	
	  return create({
	    platform: 'slack',
	    type: 'attachments',
	    text: 'App sent an attachments',
	    raw: {
	      channelId: channelId,
	      attachments: attachments,
	      options: options
	    }
	  });
	};
	
	var createReaction = function createReaction(name) {
	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	  return create({
	    platform: 'slack',
	    type: 'reaction',
	    text: 'App sent a reaction',
	    raw: {
	      name: name,
	      options: options
	    }
	  });
	};
	
	var createUpdateText = function createUpdateText(ts, channelId, text) {
	  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
	
	  validateChannelId(channelId);
	  validateText(text);
	
	  return create({
	    platform: 'slack',
	    type: 'update_text',
	    text: text,
	    raw: {
	      channelId: channelId,
	      ts: ts,
	      options: options
	    }
	  });
	};
	
	var createUpdateAttachments = function createUpdateAttachments(ts, channelId, attachments) {
	  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
	
	  validateChannelId(channelId);
	  validateAttachments(attachments);
	
	  return create({
	    platform: 'slack',
	    type: 'update_attachments',
	    text: 'App updated an attachments',
	    raw: {
	      channelId: channelId,
	      attachments: attachments,
	      ts: ts,
	      options: options
	    }
	  });
	};
	
	var createDeleteTextOrAttachments = function createDeleteTextOrAttachments(ts, channelId) {
	  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	
	  validateChannelId(channelId);
	
	  return create({
	    platform: 'slack',
	    type: 'delete_text_or_attachments',
	    text: 'App deleted a text or an attachments',
	    raw: {
	      channelId: channelId,
	      ts: ts,
	      options: options
	    }
	  });
	};
	
	var createRemoveReaction = function createRemoveReaction(name) {
	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	  return create({
	    platform: 'slack',
	    type: 'remove_reaction',
	    text: 'App remove a reaction',
	    raw: {
	      name: name,
	      options: options
	    }
	  });
	};
	
	module.exports = {
	  createText: createText,
	  createAttachments: createAttachments,
	  createReaction: createReaction,
	  createUpdateText: createUpdateText,
	  createUpdateAttachments: createUpdateAttachments,
	  createDeleteTextOrAttachments: createDeleteTextOrAttachments,
	  createRemoveReaction: createRemoveReaction
	};

/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = require("bluebird");

/***/ },
/* 6 */
/***/ function(module, exports) {

	module.exports = require("lodash");

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _util = __webpack_require__(8);
	
	var _util2 = _interopRequireDefault(_util);
	
	var _lodash = __webpack_require__(6);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _actions = __webpack_require__(4);
	
	var _actions2 = _interopRequireDefault(_actions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function getChannelId(event) {
	  var channelId = _lodash2.default.get(event, 'channel.id') || _lodash2.default.get(event, 'user.channelId') || _lodash2.default.get(event, 'channelId') || _lodash2.default.get(event, 'raw.channelId') || _lodash2.default.get(event, 'raw.channel.id') || _lodash2.default.get(event, 'raw.channel');
	
	  if (!channelId) {
	    throw new Error('Could not find channelId in the incoming event.');
	  }
	
	  return channelId;
	}
	
	function getMessageTs(event) {
	  var ts = _lodash2.default.get(event, 'ts') || _lodash2.default.get(event, 'raw.ts');
	
	  if (!ts) {
	    throw new Error('Could not find message timestamp (ts) in the incoming event.');
	  }
	
	  return ts;
	}
	
	function _processOutgoing(_ref) {
	  var event = _ref.event,
	      blocName = _ref.blocName,
	      instruction = _ref.instruction;
	
	  var ins = Object.assign({}, instruction); // Create a shallow copy of the instruction
	
	  ////////
	  // PRE-PROCESSING
	  ////////
	
	  var optionsList = [];
	
	  var options = _lodash2.default.pick(instruction, optionsList);
	
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;
	
	  try {
	    for (var _iterator = optionsList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var prop = _step.value;
	
	      delete ins[prop];
	    }
	
	    /////////
	    /// Processing
	    /////////
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }
	
	  if (!_lodash2.default.isNil(instruction.attachments)) {
	    return _actions2.default.createAttachments(getChannelId(event), instruction.attachments, instruction.options);
	  }
	
	  if (!_lodash2.default.isNil(instruction.attachment)) {
	    return _actions2.default.createAttachments(getChannelId(event), [instruction.attachment], instruction.options);
	  }
	
	  if (!_lodash2.default.isNil(instruction.text)) {
	    return _actions2.default.createText(getChannelId(event), instruction.text, instruction.options);
	  }
	
	  if (!_lodash2.default.isNil(instruction.reaction)) {
	    return _actions2.default.createReaction(instruction.reaction, Object.assign({}, {
	      timestamp: getMessageTs(event),
	      channel: getChannelId(event)
	    }, instruction.options));
	  }
	
	  ////////////
	  /// POST-PROCESSING
	  ////////////
	
	  // Nothing to post-process yet
	
	  ////////////
	  /// INVALID INSTRUCTION
	  ////////////
	
	  var strRep = _util2.default.inspect(instruction, false, 1);
	  throw new Error('Unrecognized instruction on Slack in bloc \'' + blocName + '\': ' + strRep);
	}
	
	module.exports = function (bp) {
	  var _$at = _lodash2.default.at(bp, ['umm', 'umm.registerConnector']),
	      _$at2 = _slicedToArray(_$at, 2),
	      umm = _$at2[0],
	      registerConnector = _$at2[1];
	
	  umm && registerConnector && registerConnector({
	    platform: 'slack',
	    processOutgoing: function processOutgoing(args) {
	      return _processOutgoing(Object.assign({}, args, { bp: bp }));
	    },
	    templates: []
	  });
	};

/***/ },
/* 8 */
/***/ function(module, exports) {

	module.exports = require("util");

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _client = __webpack_require__(10);
	
	var _incoming = __webpack_require__(11);
	
	var _incoming2 = _interopRequireDefault(_incoming);
	
	var _axios = __webpack_require__(16);
	
	var _axios2 = _interopRequireDefault(_axios);
	
	var _bluebird = __webpack_require__(5);
	
	var _bluebird2 = _interopRequireDefault(_bluebird);
	
	var _lodash = __webpack_require__(6);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Slack = function () {
	  function Slack(bp, config) {
	    _classCallCheck(this, Slack);
	
	    if (!bp || !config) {
	      throw new Error('You need to specify botpress and config');
	    }
	
	    this.rtm = null;
	    this.config = config;
	    this.connected = false;
	  }
	
	  _createClass(Slack, [{
	    key: 'setConfig',
	    value: function setConfig(config) {
	      this.config = config;
	    }
	  }, {
	    key: 'validateConnection',
	    value: function validateConnection() {
	      if (!this.connected) {
	        throw new Error('You are not connected...');
	      }
	    }
	  }, {
	    key: 'validateText',
	    value: function validateText(text) {
	      var type = typeof text === 'undefined' ? 'undefined' : _typeof(text);
	      if (type !== 'string') {
	        throw new Error('Text format is not valid (actual: ' + type + ', required: string)');
	      }
	    }
	  }, {
	    key: 'validateChannelId',
	    value: function validateChannelId(channelId) {
	      var type = typeof channelId === 'undefined' ? 'undefined' : _typeof(channelId);
	      if (type !== 'string') {
	        throw new Error('Channel id format is not valid (actual: ' + type + ', required: string)');
	      }
	    }
	  }, {
	    key: 'validateAttachments',
	    value: function validateAttachments(attachments) {
	      var type = typeof attachments === 'undefined' ? 'undefined' : _typeof(attachments);
	      if (type !== 'object') {
	        throw new Error('Attachments format is not valid (actual: ' + type + ', required: object)');
	      }
	    }
	  }, {
	    key: 'validateOptions',
	    value: function validateOptions(options) {
	      var type = typeof options === 'undefined' ? 'undefined' : _typeof(options);
	      if (type !== 'object') {
	        throw new Error('Options format is not valid (actual: ' + type + ', required: object)');
	      }
	    }
	  }, {
	    key: 'validateBeforeReaction',
	    value: function validateBeforeReaction(options) {
	      if (!(options.file || options.file_comment || options.channel || options.timestamp)) {
	        throw new Error('You need to set at least a destination options (file, file_comment, channel, timestamp)...');
	      }
	    }
	  }, {
	    key: 'validateBeforeSending',
	    value: function validateBeforeSending(channelId, options) {
	      this.validateConnection();
	      this.validateChannelId(channelId);
	      this.validateOptions(options);
	    }
	  }, {
	    key: 'sendText',
	    value: function sendText(channelId, text, options) {
	      var _this = this;
	
	      this.validateBeforeSending(channelId, options);
	      this.validateText(text);
	
	      return _bluebird2.default.fromCallback(function (cb) {
	        _this.web.chat.postMessage(channelId, text, options, cb);
	      });
	    }
	  }, {
	    key: 'sendUpdateText',
	    value: function sendUpdateText(ts, channelId, text, options) {
	      var _this2 = this;
	
	      this.validateBeforeSending(channelId, options);
	      this.validateText(text);
	
	      return _bluebird2.default.fromCallback(function (cb) {
	        _this2.web.chat.update(ts, channelId, text, options, cb);
	      });
	    }
	  }, {
	    key: 'sendDeleteTextOrAttachments',
	    value: function sendDeleteTextOrAttachments(ts, channelId, options) {
	      var _this3 = this;
	
	      this.validateBeforeSending(channelId, options);
	
	      return _bluebird2.default.fromCallback(function (cb) {
	        _this3.web.chat.delete(ts, channelId, options, cb);
	      });
	    }
	  }, {
	    key: 'sendAttachments',
	    value: function sendAttachments(channelId, attachments, options) {
	      var _this4 = this;
	
	      this.validateBeforeSending(channelId, options);
	      this.validateAttachments(attachments);
	
	      return _bluebird2.default.fromCallback(function (cb) {
	        _this4.web.chat.postMessage(channelId, null, _extends({
	          attachments: attachments
	        }, options), cb);
	      });
	    }
	  }, {
	    key: 'sendUpdateAttachments',
	    value: function sendUpdateAttachments(ts, channelId, attachments, options) {
	      var _this5 = this;
	
	      this.validateBeforeSending(channelId, options);
	      this.validateAttachments(attachments);
	
	      return _bluebird2.default.fromCallback(function (cb) {
	        _this5.web.chat.update(ts, channelId, null, _extends({
	          attachments: attachments
	        }, options), cb);
	      });
	    }
	  }, {
	    key: 'sendReaction',
	    value: function sendReaction(name, options) {
	      var _this6 = this;
	
	      this.validateConnection();
	      this.validateBeforeReaction(options);
	
	      return _bluebird2.default.fromCallback(function (cb) {
	        _this6.web.reactions.add(name, options, cb);
	      });
	    }
	  }, {
	    key: 'sendRemoveReaction',
	    value: function sendRemoveReaction(name, options) {
	      var _this7 = this;
	
	      this.validateConnection();
	      this.validateBeforeReaction(options);
	
	      return _bluebird2.default.fromCallback(function (cb) {
	        _this7.web.reactions.remove(name, options, cb);
	      });
	    }
	  }, {
	    key: 'isConnected',
	    value: function isConnected() {
	      return this.connected;
	    }
	  }, {
	    key: 'getData',
	    value: function getData() {
	      return this.data;
	    }
	  }, {
	    key: 'getUserProfile',
	    value: function getUserProfile(userId) {
	      var _this8 = this;
	
	      var user = _lodash2.default.find(this.getUsers(), _lodash2.default.matchesProperty('id', userId));
	
	      if (user !== 'undefined') return _bluebird2.default.resolve(user);
	
	      var url = 'https://slack.com/api/users.list' + '?token=' + this.config.apiToken;
	
	      return _axios2.default.get(url).then(function (_ref) {
	        var data = _ref.data;
	
	        if (!data.ok) {
	          throw new Error('Error getting user profile:' + userId);
	        }
	
	        _this8.data.users = data.members;
	
	        return _lodash2.default.find(data.members, _lodash2.default.matchesProperty('id', userId));
	      }).catch(function (err) {
	        return console.log('Error getting user profile: ' + err);
	      });
	    }
	  }, {
	    key: 'connectRTM',
	    value: function connectRTM(bp, rtmToken) {
	      var _this9 = this;
	
	      if (this.rtm) {
	        this.rtm.removeAllListeners();
	        this.disconnect();
	      }
	
	      this.rtm = new _client.RtmClient(rtmToken);
	
	      this.rtm.on(_client.CLIENT_EVENTS.RTM.AUTHENTICATED, function (rtmStartData) {
	        bp.logger.info('slack connector is authenticated');
	        _this9.data = rtmStartData;
	      });
	
	      this.rtm.on(_client.CLIENT_EVENTS.RTM.RTM_CONNECTION_OPENED, function () {
	        bp.logger.info('slack connector is connected');
	
	        if (!_this9.connected) {
	          _this9.connected = true;
	          (0, _incoming2.default)(bp, _this9);
	        }
	      });
	
	      this.rtm.start();
	    }
	  }, {
	    key: 'connectWebclient',
	    value: function connectWebclient(apiToken) {
	      this.web = new _client.WebClient(apiToken);
	    }
	  }, {
	    key: 'getRTMToken',
	    value: function getRTMToken() {
	      var botToken = this.config.botToken;
	      return botToken ? botToken : this.config.apiToken;
	    }
	  }, {
	    key: 'getBotId',
	    value: function getBotId() {
	      return this.data && this.data.self.id;
	    }
	  }, {
	    key: 'getBotName',
	    value: function getBotName() {
	      return this.data && this.data.self.name;
	    }
	  }, {
	    key: 'getChannelsFromAPI',
	    value: function getChannelsFromAPI() {
	      var url = 'https://slack.com/api/channels.list' + '?token=' + this.config.apiToken;
	      return _axios2.default.get(url).then(function (_ref2) {
	        var data = _ref2.data;
	
	
	        if (!data.ok) {
	          throw new Error('Error getting channels:' + data);
	        }
	
	        return data.channels;
	      });
	    }
	  }, {
	    key: 'getChannels',
	    value: function getChannels() {
	      if (!/channels:read/.test(this.config.scope)) {
	        return _bluebird2.default.resolve(this.data.channels);
	      }
	
	      return this.getChannelsFromAPI();
	    }
	  }, {
	    key: 'getTeam',
	    value: function getTeam() {
	      return this.data && this.data.team;
	    }
	  }, {
	    key: 'getUsers',
	    value: function getUsers() {
	      return this.data && this.data.users;
	    }
	  }, {
	    key: 'connect',
	    value: function connect(bp) {
	      var rtmToken = this.getRTMToken();
	
	      if (!rtmToken) return;
	
	      this.connectRTM(bp, rtmToken);
	      this.connectWebclient(rtmToken);
	    }
	  }, {
	    key: 'disconnect',
	    value: function disconnect() {
	      this.rtm.disconnect();
	    }
	  }]);
	
	  return Slack;
	}();
	
	module.exports = Slack;

/***/ },
/* 10 */
/***/ function(module, exports) {

	module.exports = require("@slack/client");

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _client = __webpack_require__(10);
	
	var _lruCache = __webpack_require__(12);
	
	var _lruCache2 = _interopRequireDefault(_lruCache);
	
	var _lodash = __webpack_require__(6);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _users = __webpack_require__(13);
	
	var _users2 = _interopRequireDefault(_users);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var OTHER_RTM_EVENTS = ['ACCOUNTS_CHANGED', 'BOT_ADDED', 'BOT_CHANGED', 'CHANNEL_ARCHIVE', 'CHANNEL_CREATED', 'CHANNEL_DELETED', 'CHANNEL_HISTORY_CHANGED', 'CHANNEL_JOINED', 'CHANNEL_LEFT', 'CHANNEL_MARKED', 'CHANNEL_RENAME', 'CHANNEL_UNARCHIVE', 'COMMANDS_CHANGED', 'DND_UPDATED', 'DND_UPDATED_USER', 'EMAIL_DOMAIN_CHANGED', 'EMOJI_CHANGED', 'FILE_CHANGE', 'FILE_COMMENT_ADDED', 'FILE_COMMENT_DELETED', 'FILE_COMMENT_EDITED', 'FILE_CREATED', 'FILE_DELETED', 'FILE_PUBLIC', 'FILE_UNSHARED', 'GOODBYE', 'GROUP_ARCHIVE', 'GROUP_CLOSE', 'GROUP_HISTORY_CHANGED', 'GROUP_JOINED', 'GROUP_LEFT', 'GROUP_MARKED', 'GROUP_OPEN', 'GROUP_RENAME', 'GROUP_UNARCHIVE', 'HELLO', 'IM_CLOSE', 'IM_CREATED', 'IM_HISTORY_CHANGED', 'IM_MARKED', 'IM_OPEN', 'MANUAL_PRESENCE_CHANGE', 'PIN_ADDED', 'PIN_REMOVED', 'PREF_CHANGE', 'PRESENCE_CHANGE', 'REACTION_REMOVED', 'RECONNECT_URL', 'STAR_ADDED', 'STAR_REMOVED', 'SUBTEAM_CREATED', 'SUBTEAM_SELF_ADDED', 'SUBTEAM_SELF_REMOVED', 'SUBTEAM_UPDATED', 'TEAM_DOMAIN_CHANGE', 'TEAM_JOIN', 'TEAM_MIGRATION_STARTED', 'TEAM_PLAN_CHANGE', 'TEAM_PREF_CHANGE', 'TEAM_PROFILE_CHANGE', 'TEAM_PROFILE_DELETE', 'TEAM_PROFILE_REORDER', 'TEAM_RENAME', 'USER_CHANG'];
	
	var mentionRegex = new RegExp(/<@(\w+)>/gi);
	
	module.exports = function (bp, slack) {
	
	  var users = (0, _users2.default)(bp, slack);
	
	  var messagesCache = (0, _lruCache2.default)({
	    max: 10000,
	    maxAge: 60 * 60 * 1000
	  });
	
	  var isButtonAction = function isButtonAction(payload) {
	    return payload.message_ts ? true : false;
	  };
	
	  var isFromBot = function isFromBot(event) {
	    if (event.bot_id || event.subtype) {
	      return true;
	    }
	    if (event.user === slack.getBotId()) {
	      return true;
	    }
	
	    return false;
	  };
	
	  var preprocessEvent = function preprocessEvent(payload) {
	
	    var userId = payload.user;
	
	    if (isButtonAction(payload)) {
	      userId = payload.user.id;
	    }
	
	    var mid = payload.channel + '_' + payload.user + '_' + payload.ts;
	
	    if (mid && !messagesCache.has(mid)) {
	      // We already processed this message
	      payload.alreadyProcessed = true;
	    } else {
	      // Mark it as processed
	      messagesCache.set(mid, true);
	    }
	
	    return users.getOrFetchUserProfile(userId);
	  };
	
	  var extractBasics = function extractBasics(event) {
	    return {
	      platform: 'slack',
	      channel: { id: event.channel },
	      ts: event.ts,
	      direct: isDirect(event.channel),
	      raw: event
	    };
	  };
	
	  var isDirect = function isDirect(channelId) {
	    return (/^D/.test(channelId)
	    );
	  };
	
	  var isBotMentioned = function isBotMentioned(text) {
	    var match = [];
	    while (match = mentionRegex.exec(text)) {
	      var mentionedId = match[1];
	      if (mentionedId === slack.getBotId()) {
	        return true;
	      }
	    }
	
	    return false;
	  };
	
	  var router = bp.getRouter('botpress-slack', { 'auth': function auth(req) {
	      return !/\/action-endpoint/i.test(req.originalUrl);
	    } });
	
	  router.post('/action-endpoint', function (req, res) {
	
	    var payload = JSON.parse(req.body.payload);
	
	    if (!slack.isConnected()) {
	      throw new Error('You are not connected and authenticated');
	    }
	
	    if (payload.token !== slack.config.verificationToken) {
	      throw new Error('Verification token are not matching');
	    }
	
	    preprocessEvent(payload).then(function (user) {
	      // Check if this is a button or a menu action
	      var action_type = 'button';
	      var action_text = ' clicked on a button';
	      if (payload.actions[0].selected_options) {
	        action_type = 'menu';
	        action_text = ' selected a menu option';
	      }
	
	      bp.middlewares.sendIncoming({
	        platform: 'slack',
	        type: 'action',
	        text: user.profile.real_name + action_text,
	        user: user,
	        channel: payload.channel,
	        action: payload.actions[0],
	        action_type: action_type,
	        callback_id: payload.callback_id,
	        ts: payload.message_ts,
	        action_ts: payload.action_ts,
	        direct: isDirect(payload.channel.id),
	        raw: payload
	      });
	
	      // DEPRECATED for 1.0
	      bp.middlewares.sendIncoming({
	        platform: 'slack',
	        type: 'button',
	        text: user.profile.real_name + ' clicked on a button',
	        user: user,
	        channel: payload.channel,
	        button: payload.actions[0],
	        callback_id: payload.callback_id,
	        ts: payload.message_ts,
	        direct: isDirect(payload.channel.id),
	        raw: payload
	      });
	    });
	
	    res.status(200).end();
	  });
	
	  slack.rtm.on(_client.RTM_EVENTS['MESSAGE'], function handleRtmMessage(message) {
	
	    if (isFromBot(message)) return;
	
	    preprocessEvent(message).then(function (user) {
	
	      bp.middlewares.sendIncoming(_extends({
	        type: 'message',
	        text: message.text,
	        user: user,
	        bot_mentioned: isBotMentioned(message.text)
	      }, extractBasics(message)));
	
	      var match = [];
	      while (match = mentionRegex.exec(message.text)) {
	        var mentionedId = match[1];
	        if (mentionedId === slack.getBotId()) {
	          bp.middlewares.sendIncoming(_extends({
	            type: 'bot_mentioned',
	            bot_mentioned: true,
	            text: 'Bot has been mentioned',
	            user: user,
	            mentionedId: mentionedId
	          }, extractBasics(message)));
	        } else {
	          bp.middlewares.sendIncoming(_extends({
	            type: 'user_mentioned',
	            user_mentioned: true,
	            text: 'User has been mentioned',
	            user: user,
	            mentionedId: mentionedId
	          }, extractBasics(message)));
	        }
	      }
	    });
	  });
	
	  slack.rtm.on(_client.RTM_EVENTS['REACTION_ADDED'], function handleRtmReactionAdded(reaction) {
	
	    if (isFromBot(reaction)) return;
	
	    preprocessEvent(reaction).then(function (user) {
	      bp.middlewares.sendIncoming(_extends({
	        type: 'reaction',
	        user: user,
	        text: user.profile.real_name + ' reacted using ' + reaction.reaction,
	        reaction: reaction.reaction
	      }, extractBasics(reaction), {
	        ts: reaction.event_ts
	      }));
	    });
	  });
	
	  slack.rtm.on(_client.RTM_EVENTS['USER_TYPING'], function handleRtmTypingAdded(typing) {
	
	    if (isFromBot(typing)) return;
	
	    preprocessEvent(typing).then(function (user) {
	      bp.middlewares.sendIncoming(_extends({
	        type: 'typing',
	        user: user,
	        text: user.profile.real_name + ' is typing'
	      }, extractBasics(typing)));
	    });
	  });
	
	  slack.rtm.on(_client.RTM_EVENTS['FILE_SHARED'], function handleRtmTypingAdded(file) {
	
	    if (isFromBot(file)) return;
	
	    users.getOrFetchUserProfile(file.user_id).then(function (user) {
	      bp.middlewares.sendIncoming({
	        platform: 'slack',
	        type: 'file',
	        user: user,
	        text: user.profile.real_name + ' shared a file',
	        file: file.file,
	        ts: file.event_ts,
	        raw: file
	      });
	    });
	  });
	
	  OTHER_RTM_EVENTS.map(function (rtmEvent) {
	    slack.rtm.on(_client.RTM_EVENTS[rtmEvent], function handleOtherRTMevent(event) {
	
	      bp.middlewares.sendIncoming({
	        platform: 'slack',
	        type: event.type,
	        text: 'An another type of event occured',
	        raw: event
	      });
	    });
	  });
	};

/***/ },
/* 12 */
/***/ function(module, exports) {

	module.exports = require("lru-cache");

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 *
	 * User info helper.
	 *
	 * This helper provides following methods:
	 *
	 *   - getOrFetchUserProfile: given `userId` return a promise of user data (with cache)
	 *
	 * Data users' profiles will be cached in `${bp.dataLocation}/botpress-slack.profiles.json`
	 *
	 */
	
	var Promise = __webpack_require__(5);
	var path = __webpack_require__(14);
	var fs = __webpack_require__(15);
	
	module.exports = function (bp, slack) {
	
	  var filename = path.join(bp.dataLocation, 'botpress-slack.profiles.json');
	
	  var loadUserProfiles = function loadUserProfiles() {
	    if (fs.existsSync(filename)) {
	      return JSON.parse(fs.readFileSync(filename));
	    }
	    return {};
	  };
	
	  var saveUserProfiles = function saveUserProfiles(profiles) {
	    var content = JSON.stringify(profiles);
	    fs.writeFileSync(filename, content);
	    bp.logger.debug('slack: saved user profiles to disk');
	  };
	
	  var userProfiles = loadUserProfiles();
	  var cacheTs = new Date();
	
	  return {
	    getOrFetchUserProfile: Promise.method(function (userId) {
	      if (userProfiles[userId]) {
	        return userProfiles[userId];
	      }
	
	      return slack.getUserProfile(userId).then(function (user) {
	        user.id = userId;
	        userProfiles[userId] = user;
	
	        if (new Date() - cacheTs >= 10000) {
	          saveUserProfiles(userProfiles);
	          cacheTs = new Date();
	        }
	
	        return bp.db.saveUser({
	          id: user.id,
	          platform: 'slack',
	          gender: 'unknown',
	          timezone: user.tz_offset / 3600,
	          locale: 'en',
	          picture_url: user.profile.img_512,
	          first_name: user.profile.first_name,
	          last_name: user.profile.last_name
	        }).return(user);
	      });
	    })
	  };
	};

/***/ },
/* 14 */
/***/ function(module, exports) {

	module.exports = require("path");

/***/ },
/* 15 */
/***/ function(module, exports) {

	module.exports = require("fs");

/***/ },
/* 16 */
/***/ function(module, exports) {

	module.exports = require("axios");

/***/ }
/******/ ]);
//# sourceMappingURL=node.bundle.js.map